# Домашние задания к Модулю III

Сдача домашних заданий выполняется путем демонстрации работы программы преподавателю на котрольных примерах, которые следует подготовить самостоятельно.

## 1. Утилита `tree`

Реализуйте собственный вариант утилиты `tree`. Пусть ваша программа поддерживает по меньшей мере ключи `-d` и `-o` так же, как реализация утилиты `tree` в ОС Linux. Поддержку других ключей можно не реализовывать. 

Программа не должна аварийно завершаться, если права доступа запрещают получение списка файлов какого-либо каталога.

## 2. Утилита `grep`

Реализуйте собственный вариант утилиты `grep`. Допускается ограничиться работой только с текстовыми файлами. Так же, как и стандартная утилита `grep`, ваша программа должна обрабатывать как стандартный ввод, так и файлы, пути к которым указаны в командной строке. Ключ `-e` должен позволять передать программе регулярное выражение Python вместо строки для поиска. Пусть ваша реализация также поддерживает ключи `-i`, `-m`, `-n` так же, как это делает стандартная реализация утилиты `grep`. Поддержку других ключей можно не реализовывать. 

Программа не должна аварийно завершаться, если какой-либо из файлов, перечисленных в аргументах командной строки, не может быть прочитан.

Сообщения об ошибках и предупреждения должны направляться в стандартный поток вывода ошибок. Направление таких сообщений в стандартный поток вывода не допускается.

## 3. Утилита `wc`

Реализуйте собственный вариант утилиты `wc`. Так же, как и стандартная утилита `wc`, ваша программа должна обрабатывать как стандартный ввод, так и файлы, пути к которым указаны в командной строке. Пусть ваша реализация поддерживает ключи `-c`, `-m`, `-w`, `-l` так же, как это делает стандартная реализация утилиты `wc`. Поддержку других ключей можно не реализовывать.

Сообщения об ошибках и предупреждения должны направляться в стандартный поток вывода ошибок. Направление таких сообщений в стандартный поток вывода не допускается.

## 4. Поиск опечаток

Реализуйте простейшую программу проверки орфографии. Пусть программа принимает на вход словарь и текст на естественном языке и выводит список и координаты слов (строка, колонка), которые не встречаются в словаре. 

Например, пусть `dictionary.txt` — словарь, а `example-missprint.txt` — текст, где в строке 1 допущена опечатка в слове `general`, во 2 строке — в слове `emphasizes` и в 7 строке — в слове `supports` (1-е буквы этих слов находятся в 25, 23 и 8 колонках соответственно). Тогда вызов и результат работы вашей программы `speller.py` должен выглядеть так: 

```bash
> ./speller.py dictionary.txt example-missprint.txt
1,  25	  gneral
2,  23	  emphasises
7,   8	  suports
```

Считайте, что в проверяемом тексте переносы слов отсутствуют. Различные формы одного слова рассматривайте как разные слова. Апостроф считайте частью слова.

### Рекомендации

В виде отдельного модуля реализуйте сканер, преобразующий текст в токены — слова и знаки пунктуации. Для каждого токена храните его координаты в исходном тексте — позицию от начала текста, номер строки, номер колонки.

Для быстрого поиска слова в словаре используйте встроенный тип данных `Set`.

Тестирование программы выполните на примерах коротких английских текстов.

Словарь получите из текста, в котором, как вы считаете, отсутствуют опечатки. Для получения отдельных слов из этого текста используйте разработанный вами сканер. Избежать повторов слов в словаре позволит использование встроенного типа данных `set`.  Напишите вспомогательную программу, которая будет строить словарь по тексту, поданному на вход этой программы.

## 5. Мемоизация произвольной чистой функции

*Необязательное задание повышенной сложности*

Реализуйте декоратор для мемоизации произвольной чистой функции, решение оформите в виде отдельного модуля. Декоратор должен допускать в том числе мемоизацию функции с именованными аргументами и со значениями аргументов по умолчанию. Считайте, что аргументы передаются в функцию по значению. Пример использования декоратора:

```python
@memoized
def trib(n):
    if n <= 1:
        return 0
    elif n == 2:
        return 1
    else:
        return trib(n-1) + trib(n-2) + trib(n-3)
```

Проверьте эффективность мемоизации на традиционных примерах: вычислении факториала, чисел Фибоначчи, «чисел трибоначчи», функции Аккермана. Для измерения времени вычисления используйте средства модуля `timeit` из стандартной библиотеки языка Python. Результаты измерений для разных значений аргументов сведите в таблицу, позволяющую сравнить эффективность мемоизованной и немемоизованной функций.

### Рекомендации

Учитывайте, что экземпляр класса, для которого определен метод `__call__`, можно рассматривать как функцию. В свою очередь, функцию можно рассматривать как воплощение класса, в котором имеется определение метода `__call__`. 

Получить список имен атрибутов и методов, определенных в классе, можно с помощью встроенной функции `dir`. 
 
