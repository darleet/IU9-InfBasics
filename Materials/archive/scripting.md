# Модуль 3. Программирование на &laquo;скриптовых&raquo; языках

## Цели работы

* Получение начальных навыков написания сценариев &laquo;скриптов&raquo;.
* Получение навыков работы с технической документацией.
* Знакомство со стандартыми утилитами командной строки.

## Теоретическая часть

На ваш выбор, ознакомьтесь с одним из следующих языков программирования:

* JavaScript (Node.js в режиме `'use strict;'`)
* Python (3.x)
* Scheme, редакция R6RS (рекомендуется использовать Guile 2.x)

В процессе чтения руководств и документации рекомендуется вести конспект, придерживаясь следующего плана:

1. Типизация и система типов языка.
2. Основные управляющие конструкции.
3. Подмножество языка для функционального программирования: способы обеспечить иммутабельность данных там, где это необходимо, функции как объекты 1-го класса, функции высших порядков, встроенные функции высших порядков для работы с последовательностями (`map`, `for-each`, `reduce`, `filter`).
4. Важнейшие функции для работы с потоками ввода/вывода, строками, регулярными выражениями.

Конспект оформите в виде текста (4-6 страниц А4, шрифт 10-12pt, полуторный интервал, офрмление в стиле cheatsheet приветствуется) и сдайте преподавателю.

## Задачи

Сдача домашних заданий выполняется путем демонстрации работы программы преподавателю на котрольных примерах, которые следует подготовить самостоятельно.

### 1. Утилита `tree`

Реализуйте собственный вариант утилиты `tree`. Пусть ваша программа поддерживает по меньшей мере ключи `-d` и `-o` так же, как реализация утилиты `tree` в ОС Linux. Поддержку других ключей можно не реализовывать.

Программа не должна аварийно завершаться, если права доступа запрещают получение списка файлов какого-либо каталога.

### 2. Утилита `grep`

Реализуйте собственный вариант утилиты `grep`. Допускается ограничиться работой только с текстовыми файлами. Так же, как и стандартная утилита `grep`, ваша программа должна обрабатывать как стандартный ввод, так и файлы, пути к которым указаны в командной строке. Ключ `-e` должен позволять передать программе регулярное выражение Python вместо строки для поиска. Пусть ваша реализация также поддерживает ключи `-i`, `-m`, `-n` так же, как это делает стандартная реализация утилиты `grep`. Поддержку других ключей можно не реализовывать.

Программа не должна аварийно завершаться, если какой-либо из файлов, перечисленных в аргументах командной строки, не может быть прочитан.

Сообщения об ошибках и предупреждения должны направляться в стандартный поток вывода ошибок. **Направление таких сообщений в стандартный поток вывода не допускается.**

### 3. Утилита `wc`

Реализуйте собственный вариант утилиты `wc`. Так же, как и стандартная утилита `wc`, ваша программа должна обрабатывать как стандартный ввод, так и файлы, пути к которым указаны в командной строке. Пусть ваша реализация поддерживает ключи `-c`, `-m`, `-w`, `-l` так же, как это делает стандартная реализация утилиты `wc`. Поддержку других ключей можно не реализовывать.

Сообщения об ошибках и предупреждения должны направляться в стандартный поток вывода ошибок. **Направление таких сообщений в стандартный поток вывода не допускается.**

### 4. Поиск опечаток

Реализуйте простейшую программу проверки орфографии. Пусть программа принимает на вход словарь и текст на естественном языке и выводит список и координаты слов (строка, колонка), которые не встречаются в словаре.

Например, пусть `dictionary.txt` -- словарь, а `example-missprint.txt` -- текст, где в строке 1 допущена опечатка в слове `general`, во 2 строке -- в слове `emphasizes` и в 7 строке -- в слове `supports` (1-е буквы этих слов находятся в 25, 23 и 8 колонках соответственно). Тогда вызов и результат работы вашей программы `speller.py` должен выглядеть так:

```
> ./speller.py dictionary.txt example-missprint.txt
1,  25	  gneral
2,  23	  emphasises
7,   8	  suports
```

Считайте, что в проверяемом тексте переносы слов отсутствуют. Различные формы одного слова рассматривайте как разные слова. Апостроф считайте частью слова.

#### Рекомендации

В виде отдельного модуля реализуйте сканер, преобразующий текст в токены -- слова и знаки пунктуации. Для каждого токена храните его координаты в исходном тексте -- позицию от начала текста, номер строки, номер колонки.

Тестирование программы выполните на примерах коротких английских текстов.

Словарь получите из текста, в котором, как вы считаете, отсутствуют опечатки. Для получения отдельных слов из этого текста используйте разработанный вами сканер. Напишите вспомогательную программу, которая будет строить словарь по тексту, поданному на вход этой программы.

### 5. Мемоизация произвольной чистой функции

*Необязательное задание повышенной сложности*

Реализуйте для мемоизацию произвольной чистой функции, решение оформите в виде отдельного модуля. Если выбранный вами язык программирования должен допускать в том числе мемоизацию функции с именованными аргументами и со значениями аргументов по умолчанию. Считайте, что аргументы передаются в функцию по значению.

Проверьте эффективность мемоизации на традиционных примерах: вычислении факториала, чисел Фибоначчи, «чисел трибоначчи», функции Аккермана. Для измерения времени вычисления используйте стандартную утилиту командной строки `time` и/или функции даты/времени из стандартной библиотеки вашего интерпретатора. Результаты измерений для разных значений аргументов сведите в таблицу, позволяющую сравнить эффективность мемоизованной и немемоизованной функций.
