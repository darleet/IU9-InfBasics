**Лабораторная работа №5 (Вариант I)**

# Основы лексического и синтакисческого анализа

## Цель работы

Получение навыков реализации лексических анализаторов и нисходящих синтаксических анализаторов, использующих метод рекурсивного спуска.

## Вопросы для допуска к работе

0.  Дайте определение понятию «грамматика». В его контексте определите понятия «терминиальный символ», «нетерминальный символ», «правило грамматики».

0.  Какая из приведенных ниже грамматик является LL(1)-грамматикой? Можно ли непосредственно на основе этой грамматики реализовать нисходящий рекурсивный парсер? Почему? Приведите пример исходной последовательности для этой грамматики.

    *   S → A \| B <br/>
        A → B A \| ε <br/>
        B → x \| y A z

    *   S → A \| B <br/>
        A → x A \| B <br/>
        B → x B y \| ε
    
0.  Какой вычислительный процесс — линейно- или древовидно-рекурсивный имеет место в случае: (а) синтаксического анализа, (б) лексического анализа? Почему?

## Задания

1.  Реализуйте простейшие сканеры:

    +   Процедуру `check-hex`, принимающую на вход строку и возвращающую `#t`, если в строке записано шестнадцатеричное целое число без знака в формате, принятом в языке C, и `#f` в противном случае. Запрещается применять встроенную процедуру для преобразования строки к числу. 

    +   Процедуру `scan-hex`, принимающую на вход строку и возвращающую десятичное целое число, если оно было записано в этой строке в шестнадцатеричной системе счисления, и `#f` в противном случае. Запрещается применять встроенные процедуры преобразования типов непосредственно к исходной строке до её посимвольной обработки сканером.

    +   Процедуру `scan-many-hexs`, принимающую на вход строку, содержащую шестнадцатеричные числа без знака, разделенные пробельными символами (строка также может начинаться и заканчиваться произвольным числом пробелов, символов табуляции, перевода строки и др.), и возвращающую список десятичных целых чисел. Если разбор не возможен, процедура должна возвращать `#f`. Запрещается применять встроенные процедуры преобразования типов непосредственно к исходной строке или её фрагментам до её посимвольной обработки сканером.

    Примеры вызова процедур:

    ```nohighlight
    (check-hex "0x1")   ⇒ #t
    (check-hex "0X2A")  ⇒ #t
    (check-hex "0XFFF") ⇒ #t
    (check-hex "0X025") ⇒ #t
    (check-hex "123")   ⇒ #f

    (scan-hex "0x0")   ⇒ 0
    (scan-hex "0X10A") ⇒ 266
    (scan-hex "0x1")   ⇒ 1
    (scan-hex "12")    ⇒ #f

    (scan-many-hexs "\t0x1\t\t0x2\n0xff00") 
        ⇒ (1 2 65280)
    (scan-many-hexs "0x0, 123") ⇒ #f
    ```
    
    В начале текста программы, в комментариях, обязательно запишите грамматику в БНФ или РБНФ, которую реализуют ваши сканеры.

    Рекомендация. Символ, маркирующий конец последовательности, выберете исходя из того, что на вход вашего лексера может поступить любая последовательность символов из таблицы ASCII, встречающаяся в текстовых файлах.

2.  Реализуйте процедуру `parse`, осуществляющую разбор программы на модельном языке, представленную в виде последовательности (вектора) токенов (см. Лабораторную работу №4 «Интерпретатор стекового языка программирования»). Процедура `parse` должна включать в себя реализацию синтаксического анализа последовательности токенов методом рекурсивного спуска согласно следующей грамматикe:

    ```nohighlight
    <Program>  ::= <Articles> <Body> .
    <Articles> ::= <Article> <Articles> | .
    <Article>  ::= define word <Body> end .
    <Body>     ::= if <Body> endif <Body> | integer <Body> | word <Body> | .
    ```

    Процедура должна возвращать синтаксическое дерево в виде вложенных списков, соответствующих нетерминалам грамматики. В случае несоответствия входной последовательности грамматике процедура должна возвращать `#f`. Примеры применения процедуры:

    ```nohighlight
    (parse #(1 2 +)) ⇒ (() (1 2 +))

    (parse #(x dup 0 swap if drop -1 endif)) 
        ⇒ (() (x dup 0 swap (if (drop -1))))

    (parse #( define -- 1 - end 
              define =0? dup 0 = end 
              define =1? dup 1 = end 
              define factorial 
                  =0? if drop 1 exit endif 
                  =1? if drop 1 exit endif 
                  dup -- 
                  factorial 
                  * 
              end 
              0 factorial 
              1 factorial 
              2 factorial 
              3 factorial 
              4 factorial ))
     ⇒
     (((-- (1 -))
       (=0? (dup 0 =))
       (=1? (dup 1 =))
       (factorial
        (=0? (if (drop 1 exit)) =1? (if (drop 1 exit)) dup -- factorial *)))
      (0 factorial 1 factorial 2 factorial 3 factorial 4 factorial))

    (parse #(define word w1 w2 w3)) ⇒ #f
    ```

    Подготовьте еще 2-3 примера для демонстрации. Обратите внимание, что грамматика позволяет записывать на исходном языке вложенные конструкции `if` .. `endif`. Учтите эту особенность при реализации парсера и продемонстрируйте её на примерах.
    
    Как изменится грамматика, если допустить вложенные статьи?
    

